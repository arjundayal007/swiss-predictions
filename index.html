<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Esports Swiss-System Tournament</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f5;
            margin: 0;
            padding: 20px;
        }

        h1, h2 {
            text-align: center;
        }

        .container {
            max-width: 1200px;
            margin: auto;
        }

        .section {
            background-color: #fff;
            padding: 20px;
            margin-bottom: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .section h2 {
            margin-top: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        th, td {
            padding: 8px 12px;
            border: 1px solid #ddd;
            text-align: center;
        }

        th {
            background-color: #4CAF50;
            color: white;
        }

        input[type="text"], select, input[type="number"] {
            width: 100%;
            padding: 8px 12px;
            margin: 6px 0 12px 0;
            box-sizing: border-box;
        }

        button {
            background-color: #4CAF50;
            color: white;
            padding: 10px 16px;
            margin: 10px 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        .hidden {
            display: none;
        }

        .match-result {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .match-result input {
            width: 60px;
            margin: 0 5px;
            text-align: center;
        }

        .status-promoted {
            background-color: #d4edda;
            color: #155724;
            padding: 5px;
            border-radius: 4px;
        }

        .status-eliminated {
            background-color: #f8d7da;
            color: #721c24;
            padding: 5px;
            border-radius: 4px;
        }

        .status-active {
            background-color: #fff3cd;
            color: #856404;
            padding: 5px;
            border-radius: 4px;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>Esports Swiss-System Tournament</h1>

    <!-- Team Input Section -->
    <div class="section" id="team-input-section">
        <h2>1. Enter Team Names and Seeds</h2>
        <form id="team-form">
            <table>
                <thead>
                    <tr>
                        <th>Seed</th>
                        <th>Team Name</th>
                    </tr>
                </thead>
                <tbody id="team-table-body">
                    <!-- Dynamically Generated Team Inputs -->
                </tbody>
            </table>
            <button type="submit">Start Tournament</button>
        </form>
    </div>

    <!-- Tournament Management Section -->
    <div class="section hidden" id="tournament-section">
        <h2>2. Tournament Matches</h2>

        <!-- Current Round Display -->
        <div id="current-round-display">
            <h3>Round <span id="current-round-number"></span></h3>
        </div>

        <!-- Matches Display -->
        <div id="matches-display">
            <!-- Dynamically Generated Matches -->
        </div>

        <!-- Button to Generate Next Round -->
        <button id="next-round-button" class="hidden">Generate Next Round</button>
    </div>

    <!-- Standings Section -->
    <div class="section hidden" id="standings-section">
        <h2>3. Current Standings</h2>
        <table>
            <thead>
                <tr>
                    <th>Seed</th>
                    <th>Team Name</th>
                    <th>Wins</th>
                    <th>Losses</th>
                    <th>Buchholz Score</th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody id="standings-table-body">
                <!-- Dynamically Generated Standings -->
            </tbody>
        </table>
    </div>
</div>

<script>
    // Tournament Configuration
    const MAX_WINS = 3;
    const MAX_LOSSES = 3;
    const TOTAL_TEAMS = 16;
    const INITIAL_ROUNDS = 2;
    const TOTAL_ROUNDS = 5;

    // Tournament Data Structures
    let teams = [];
    let matches = [];
    let currentRound = 1;
    let matchIdCounter = 0; // Unique identifier for each match

    // Team Status Enum
    const TeamStatus = {
        ACTIVE: 'Active',
        PROMOTED: 'Promoted',
        ELIMINATED: 'Eliminated'
    };

    // Initialize Team Input Form
    function initializeTeamForm() {
        const teamTableBody = document.getElementById('team-table-body');
        for (let i = 1; i <= TOTAL_TEAMS; i++) {
            const row = document.createElement('tr');

            const seedCell = document.createElement('td');
            seedCell.textContent = i;

            const nameCell = document.createElement('td');
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.required = true;
            nameInput.placeholder = `Team ${i}`;
            nameInput.dataset.seed = i;
            nameCell.appendChild(nameInput);

            row.appendChild(seedCell);
            row.appendChild(nameCell);
            teamTableBody.appendChild(row);
        }
    }

    // Handle Team Form Submission
    document.getElementById('team-form').addEventListener('submit', function(event) {
        event.preventDefault();
        const teamInputs = document.querySelectorAll('#team-table-body input');
        teams = [];
        teamInputs.forEach(input => {
            const team = {
                seed: parseInt(input.dataset.seed),
                name: input.value.trim(),
                wins: 0,
                losses: 0,
                buchholz: 0,
                status: TeamStatus.ACTIVE
            };
            teams.push(team);
        });

        // Sort teams by seed
        teams.sort((a, b) => a.seed - b.seed);

        // Hide Team Input Section and Show Tournament Section
        document.getElementById('team-input-section').classList.add('hidden');
        document.getElementById('tournament-section').classList.remove('hidden');

        // Show Standings Section
        document.getElementById('standings-section').classList.remove('hidden');

        // Initialize Standings Table
        updateStandings();

        // Generate Initial Pairings
        generatePairings();
    });

    // Generate Pairings Based on Current Round
    function generatePairings() {
        let pairings = [];

        if (currentRound <= INITIAL_ROUNDS) {
            // Dutch System: 1 vs 9, 2 vs 10, ..., 8 vs 16
            for (let i = 0; i < TOTAL_TEAMS / 2; i++) {
                const team1 = teams[i];
                const team2 = teams[i + TOTAL_TEAMS / 2];
                pairings.push({
                    id: matchIdCounter++,
                    round: currentRound,
                    team1: team1,
                    team2: team2,
                    outcome: null,
                    isBo1: true,
                    isPromotionMatch: false,
                    isEliminationMatch: false
                });
            }
        } else {
            // Swiss Pairings: Pair teams with similar scores and avoid rematches
            pairings = swissPairings();
        }

        // Add pairings to matches array
        matches.push(...pairings);
        displayMatches(pairings);
    }

    // Display Matches for the Current Round
    function displayMatches(pairings) {
        document.getElementById('current-round-number').textContent = currentRound;

        const matchesDisplay = document.getElementById('matches-display');
        matchesDisplay.innerHTML = '';

        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');

        const headers = ['Match', 'Team 1', 'Score', 'Team 2', 'Score', 'Result'];
        headers.forEach(text => {
            const th = document.createElement('th');
            th.textContent = text;
            headerRow.appendChild(th);
        });

        thead.appendChild(headerRow);
        table.appendChild(thead);

        const tbody = document.createElement('tbody');

        pairings.forEach((match, index) => {
            const row = document.createElement('tr');

            // Match Number
            const matchNumberCell = document.createElement('td');
            matchNumberCell.textContent = index + 1;
            row.appendChild(matchNumberCell);

            // Team 1
            const team1Cell = document.createElement('td');
            team1Cell.textContent = match.team1.name;
            row.appendChild(team1Cell);

            // Score Input for Team 1
            const score1Cell = document.createElement('td');
            if (match.team2) {
                const score1Input = document.createElement('input');
                score1Input.type = 'number';
                score1Input.min = 0;
                score1Input.placeholder = '0';
                score1Input.id = `score1-${match.id}`;
                score1Cell.appendChild(score1Input);
            } else {
                score1Cell.textContent = '-';
            }
            row.appendChild(score1Cell);

            // Team 2
            const team2Cell = document.createElement('td');
            team2Cell.textContent = match.team2 ? match.team2.name : 'Bye';
            row.appendChild(team2Cell);

            // Score Input for Team 2
            const score2Cell = document.createElement('td');
            if (match.team2) {
                const score2Input = document.createElement('input');
                score2Input.type = 'number';
                score2Input.min = 0;
                score2Input.placeholder = '0';
                score2Input.id = `score2-${match.id}`;
                score2Cell.appendChild(score2Input);
            } else {
                score2Cell.textContent = '-';
            }
            row.appendChild(score2Cell);

            // Result Button
            const resultCell = document.createElement('td');
            if (!match.outcome) {
                const submitButton = document.createElement('button');
                submitButton.textContent = 'Submit';
                submitButton.dataset.matchId = match.id;
                submitButton.onclick = () => submitMatchResult(match.id);
                resultCell.appendChild(submitButton);
            } else {
                const resultText = document.createElement('span');
                if (match.outcome === 'Bye') {
                    resultText.textContent = 'Bye';
                } else if (match.outcome === 'Team1Win') {
                    resultText.textContent = `${match.team1.name} Wins`;
                } else if (match.outcome === 'Team2Win') {
                    resultText.textContent = `${match.team2.name} Wins`;
                } else {
                    resultText.textContent = 'Completed';
                }
                resultCell.appendChild(resultText);
            }
            row.appendChild(resultCell);

            tbody.appendChild(row);
        });

        table.appendChild(tbody);
        matchesDisplay.appendChild(table);
    }

    // Submit Match Result
    function submitMatchResult(matchId) {
        const match = matches.find(m => m.id === matchId);
        if (!match) {
            alert('Match not found.');
            return;
        }

        if (match.outcome) {
            alert('Match already has a result.');
            return;
        }

        if (match.team2) {
            const score1 = parseInt(document.getElementById(`score1-${match.id}`).value);
            const score2 = parseInt(document.getElementById(`score2-${match.id}`).value);

            // Validate scores
            if (isNaN(score1) || isNaN(score2)) {
                alert('Please enter valid scores.');
                return;
            }

            // BO1 Score Validation
            if (match.isBo1) {
                if (!validateBo1Scores(score1, score2)) {
                    alert('Invalid scores for BO1 match.');
                    return;
                }
            }

            // Determine Outcome
            if (score1 > score2) {
                match.outcome = 'Team1Win';
                match.team1.wins += 1;
                match.team2.losses += 1;
            } else if (score2 > score1) {
                match.outcome = 'Team2Win';
                match.team2.wins += 1;
                match.team1.losses += 1;
            } else {
                alert('Scores cannot be tied in BO1 matches.');
                return;
            }
        } else {
            // Handle Bye: Automatic win for Team1
            match.outcome = 'Bye';
            match.team1.wins += 1;
        }

        // Update Team Statuses
        updateTeamStatus(match.team1);
        if (match.team2) updateTeamStatus(match.team2);

        // Update Standings
        updateStandings();

        // Update Matches Display
        displayMatches([match]);

        // Check if All Matches in Current Round are Completed
        const allMatchesCompleted = matches.filter(m => m.round === currentRound).every(m => m.outcome !== null);
        if (allMatchesCompleted) {
            document.getElementById('next-round-button').classList.remove('hidden');
        }
    }

    // Validate BO1 Scores
    function validateBo1Scores(score1, score2) {
        // A team must reach at least 7 rounds to win
        // If both teams reach 6, first to 8 wins
        if (score1 < 7 && score2 < 7) return false;
        if (score1 >= 7 && score2 < 6) return true;
        if (score2 >= 7 && score1 < 6) return true;
        if (score1 === 8 && score2 === 6) return true;
        if (score2 === 8 && score1 === 6) return true;
        return false;
    }

    // Update Team Status Based on Wins and Losses
    function updateTeamStatus(team) {
        if (team.wins >= MAX_WINS) {
            team.status = TeamStatus.PROMOTED;
        } else if (team.losses >= MAX_LOSSES) {
            team.status = TeamStatus.ELIMINATED;
        } else {
            team.status = TeamStatus.ACTIVE;
        }
    }

    // Update Standings Table
    function updateStandings() {
        const standingsBody = document.getElementById('standings-table-body');
        standingsBody.innerHTML = '';

        // Calculate Buchholz Scores
        calculateBuchholz();

        // Sort Teams: Wins Desc, Buchholz Desc, Seed Asc
        const sortedTeams = [...teams].sort((a, b) => {
            if (b.wins !== a.wins) return b.wins - a.wins;
            if (b.buchholz !== a.buchholz) return b.buchholz - a.buchholz;
            return a.seed - b.seed;
        });

        sortedTeams.forEach(team => {
            const row = document.createElement('tr');

            // Seed
            const seedCell = document.createElement('td');
            seedCell.textContent = team.seed;
            row.appendChild(seedCell);

            // Team Name
            const nameCell = document.createElement('td');
            nameCell.textContent = team.name;
            row.appendChild(nameCell);

            // Wins
            const winsCell = document.createElement('td');
            winsCell.textContent = team.wins;
            row.appendChild(winsCell);

            // Losses
            const lossesCell = document.createElement('td');
            lossesCell.textContent = team.losses;
            row.appendChild(lossesCell);

            // Buchholz
            const buchholzCell = document.createElement('td');
            buchholzCell.textContent = team.buchholz;
            row.appendChild(buchholzCell);

            // Status
            const statusCell = document.createElement('td');
            const statusSpan = document.createElement('span');
            if (team.status === TeamStatus.PROMOTED) {
                statusSpan.textContent = TeamStatus.PROMOTED;
                statusSpan.classList.add('status-promoted');
            } else if (team.status === TeamStatus.ELIMINATED) {
                statusSpan.textContent = TeamStatus.ELIMINATED;
                statusSpan.classList.add('status-eliminated');
            } else {
                statusSpan.textContent = TeamStatus.ACTIVE;
                statusSpan.classList.add('status-active');
            }
            statusCell.appendChild(statusSpan);
            row.appendChild(statusCell);

            standingsBody.appendChild(row);
        });
    }

    // Calculate Buchholz Scores
    function calculateBuchholz() {
        // Reset Buchholz
        teams.forEach(team => {
            team.buchholz = 0;
        });

        // Sum the scores of each opponent
        matches.forEach(match => {
            if (match.team2) {
                if (match.outcome === 'Team1Win') {
                    match.team1.buchholz += (match.team2.wins - match.team2.losses);
                    match.team2.buchholz += (match.team1.wins - match.team1.losses);
                } else if (match.outcome === 'Team2Win') {
                    match.team1.buchholz += (match.team2.wins - match.team2.losses);
                    match.team2.buchholz += (match.team1.wins - match.team1.losses);
                }
            }
            // Byes do not affect Buchholz
        });
    }

    // Handle Next Round Generation
    document.getElementById('next-round-button').addEventListener('click', function() {
        // Increment Round
        currentRound += 1;

        // Hide Next Round Button
        this.classList.add('hidden');

        // Generate Pairings for Next Round
        generatePairings();
    });

    // Swiss Pairing Algorithm with Buchholz
    function swissPairings() {
        const activeTeams = teams.filter(t => t.status === TeamStatus.ACTIVE);

        // Sort active teams by wins descending, then Buchholz descending, then seed ascending
        const sortedTeams = activeTeams.sort((a, b) => {
            if (b.wins !== a.wins) return b.wins - a.wins;
            if (b.buchholz !== a.buchholz) return b.buchholz - a.buchholz;
            return a.seed - b.seed;
        });

        const pairings = [];
        const used = new Set();

        for (let i = 0; i < sortedTeams.length; i++) {
            const team1 = sortedTeams[i];
            if (used.has(team1)) continue;

            for (let j = i + 1; j < sortedTeams.length; j++) {
                const team2 = sortedTeams[j];
                if (used.has(team2)) continue;

                // Check if they have played before
                const hasPlayed = matches.some(m =>
                    (m.team1 === team1 && m.team2 === team2) ||
                    (m.team1 === team2 && m.team2 === team1)
                );

                if (!hasPlayed) {
                    pairings.push({
                        id: matchIdCounter++,
                        round: currentRound,
                        team1: team1,
                        team2: team2,
                        outcome: null,
                        isBo1: true, // BO3 can be handled based on team status if needed
                        isPromotionMatch: false,
                        isEliminationMatch: false
                    });
                    used.add(team1);
                    used.add(team2);
                    break;
                }
            }
        }

        // Handle Odd Number of Teams by Assigning Bye
        const remainingTeams = sortedTeams.filter(t => !used.has(t));
        if (remainingTeams.length > 0) {
            const byeTeam = remainingTeams[0];
            pairings.push({
                id: matchIdCounter++,
                round: currentRound,
                team1: byeTeam,
                team2: null,
                outcome: null,
                isBo1: true,
                isPromotionMatch: false,
                isEliminationMatch: false
            });
        }

        return pairings;
    }

    // Initialize the Team Form on Page Load
    window.onload = initializeTeamForm;

</script>

</body>
</html>
